{"version":3,"file":"audio-engine-QnhPrbqL.js","sources":["../../src/global/paths.ts","../../src/logic/audio/audio-config.ts","../../src/logic/midi/midi-config.ts","../../src/logic/audio/WebAudioEngine.ts"],"sourcesContent":["// Constants for audio asset paths, in 'public' directory //\n\nconst MULTI_DIR = './audio/multi-sample-instruments/';\nconst SINGLE_DIR = './audio/single-samples/';\n\n/* TODO: Make this dynamic:\n\n    Create utility functions to get midi notes, extension and instr name dynamically:\n    - approaches: \n        a) from file paths (named by midi notes), \n        b) from manifest file, \n        c) other simple methods? (API?)\n    - research the manifest file approach\n*/\n\n// Use set instead of array\n// Store as sorted array for direct ordered access\nconst DEFAULT_MULTI_INSTR_MIDINOTES = [48, 50, 52, 53, 55, 57].sort(\n  (a, b) => a - b\n);\n// from C4: [60, 62, 64, 65, 67, 69]\n\n// Default multi-sample instrument:\nconst DEFAULT_MULTI_SAMPLE_INSTRUMENT = {\n  instrumentName: 'soft-piano',\n  directory: MULTI_DIR + 'default/',\n  fileExt: 'mp3',\n  // midiNotes: DEFAULT_MULTI_INSTR_MIDINOTES,\n  // paths: DEFAULT_MULTI_INSTR_MIDINOTES.map(\n  //   (note) => `${MULTI_DIR}default/${note}.mp3`\n  // ),\n  samples: DEFAULT_MULTI_INSTR_MIDINOTES.map((midiNote) => ({\n    midiNote,\n    path: `${MULTI_DIR}default/${midiNote}.mp3`,\n  })),\n};\n\n// Default single-sample instrument:\nconst DEFAULT_SINGLE_SAMPLE_INSTRUMENT = {\n  instrumentName: 'defaultSample',\n  fileExt: 'mp3',\n  directory: SINGLE_DIR + 'default/',\n  midiNote: 60,\n  path: SINGLE_DIR + 'default/' + 'sPno_60.mp3', //  'vibe_57.mp3'\n};\n\nexport const DEFAULT_INSTRUMENTS = {\n  singleSample: DEFAULT_SINGLE_SAMPLE_INSTRUMENT,\n  multiSample: DEFAULT_MULTI_SAMPLE_INSTRUMENT,\n};\n","import { DEFAULT_INSTRUMENTS } from '../../global/paths';\nimport { WebAudioEngineConfig } from './WebAudioEngine';\n\nexport const DEFAULT_CONFIG: WebAudioEngineConfig = {\n  sampler_mode: 'single-sample',\n  defaultInstruments: DEFAULT_INSTRUMENTS,\n};\n","export const MidiConfig = {\n  DEFAULTS: {\n    VELOCITY: 100,\n    MIDDLE_C: 60,\n  },\n};\n","import { DEFAULT_CONFIG } from './audio-config';\nimport { MidiNoteUtils } from '../midi/midiNote';\nimport { MidiConfig } from '../midi/midi-config';\nimport { DEFAULT_INSTRUMENTS } from '../../global/paths';\n\nexport type VoiceNode = { source: AudioBufferSourceNode; gain: GainNode };\n\nexport interface WebAudioEngineConfig {\n  sampler_mode: 'single-sample' | 'multi-sample';\n  defaultInstruments?: typeof DEFAULT_INSTRUMENTS;\n}\n\ntype SamplePath = {\n  midiNote: number;\n  path: string;\n};\n\ntype Instrument = {\n  midiBufferMap: Map<number, AudioBuffer>; // key: midiNote, value: AudioBuffer\n  midiStartTimeMap: Map<number, number>; // key: midiNote, value: startTime (default is after silenceThreshold is reached) // Or trim it off\n  // params: attack / release, endtime, loop points, volume, etc..\n  // nrSamples: number;\n  // midiNotes: number[];\n  // velocityLayers?\n  // random / variations ?\n};\n\nexport const DEFAULT_ATTACK = 0.01;\nexport const DEFAULT_RELEASE = 0.05;\n\nexport class WebAudioEngine {\n  private context: AudioContext;\n  private masterGain: GainNode;\n  silenceThreshold: number = 0.18; // test values on different samples after adding amplitude normalization\n  rootMidiNote: number = 60; // C4 - Middle C\n\n  private config: WebAudioEngineConfig;\n  private loadedInstruments: Map<string, Instrument> = new Map(); // key: id ?? , value: instrument\n\n  // could be generalized to just 'selectedInstrument/s.buffers' and if single-sample mode than only uses C4 (or closest C or user selected root pitch)\n  private singleSampleBuffers: Map<number, AudioBuffer> = new Map(); // key: index, value: audio buffer\n  private multiSampleBuffers: Map<number, AudioBuffer> = new Map(); // key: midi note, value: audio buffer\n\n  private activeVoiceNodes: Map<number, VoiceNode> = new Map();\n  private samplerMode: 'single-sample' | 'multi-sample';\n\n  constructor() {\n    this.config = DEFAULT_CONFIG;\n    this.context = new AudioContext();\n\n    this.masterGain = this.context.createGain();\n    this.masterGain.gain.value = 1;\n    this.masterGain.connect(this.context.destination);\n\n    this.samplerMode = this.config.sampler_mode;\n    // console.log('instr: ', this.config.defaultInstruments);\n  }\n\n  async initialize(): Promise<void> {\n    if (this.samplerMode === 'multi-sample') {\n      await this.loadMulti(this.config.defaultInstruments.multiSample.samples);\n    } else if (this.samplerMode === 'single-sample') {\n      await this.loadSingle(this.config.defaultInstruments.singleSample.path);\n    } else {\n      throw new Error('Invalid sampler mode');\n    }\n  }\n\n  async ensureContextRunning(): Promise<void> {\n    if (this.context.state !== 'running') {\n      await this.context.resume();\n    }\n  }\n\n  async setSamplerMode(mode: 'single-sample' | 'multi-sample'): Promise<void> {\n    if (mode === this.samplerMode) return;\n\n    if (this.activeVoiceNodes.size > 0) {\n      this.activeVoiceNodes.forEach((voice) => voice.source.stop());\n      this.activeVoiceNodes.clear();\n    }\n\n    if (mode === 'multi-sample' && this.multiSampleBuffers.size === 0) {\n      await this.loadMulti(this.config.defaultInstruments.multiSample.samples);\n    } else if (\n      mode === 'single-sample' &&\n      this.singleSampleBuffers.size === 0\n    ) {\n      await this.loadSingle(this.config.defaultInstruments.singleSample.path);\n    }\n\n    this.samplerMode = mode;\n  }\n\n  // multi-channel version (slow?)\n  private detectThresholdCrossing(audioBuffer: AudioBuffer): number {\n    const numChannels = audioBuffer.numberOfChannels;\n    const sampleRate = audioBuffer.sampleRate;\n    const samples = Array.from({ length: numChannels }, (_, i) =>\n      audioBuffer.getChannelData(i)\n    );\n\n    for (let i = 0; i < samples[0].length; i++) {\n      const maxAmplitude = Math.max(\n        ...samples.map((channel) => Math.abs(channel[i]))\n      );\n      if (maxAmplitude > this.silenceThreshold) {\n        return i / sampleRate;\n      }\n    }\n    return 0;\n  }\n\n  async fetchAudioFile(path: string): Promise<ArrayBuffer> {\n    const response = await fetch(path);\n    // console.log(\n    //   'Fetching from path:',\n    //   path,\n    //   '\\nStatus:',\n    //   response.status,\n    //   '\\nContent-Type:',\n    //   response.headers.get('Content-Type')\n    // );\n\n    if (!response.ok) {\n      throw new Error(\n        `Failed to fetch audio file: ${path} (${response.status})`\n      );\n    }\n\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    const buffer = await response.arrayBuffer();\n    if (buffer.byteLength < 2000) {\n      console.warn('Warning: Received suspiciously small audio file');\n    }\n    return buffer;\n  }\n\n  async decodeAudioData(arrayBuffer: ArrayBuffer): Promise<AudioBuffer> {\n    if (!this.context) {\n      throw new Error('Audio context not initialized');\n    }\n    if (!(this.context.state === 'running')) {\n      this.context.resume();\n      console.log('Resuming audio context');\n    }\n    if (!arrayBuffer) {\n      throw new Error('Array buffer is empty');\n    }\n\n    return this.context.decodeAudioData(arrayBuffer);\n  }\n\n  async loadSingle(path: string): Promise<void> {\n    this.rootMidiNote = this.config.defaultInstruments.singleSample.midiNote; // REFACTOR THIS !!\n\n    const arrayBuffer = await this.fetchAudioFile(path);\n    const audioBuffer = await this.decodeAudioData(arrayBuffer);\n\n    const thresholdTime = this.detectThresholdCrossing(audioBuffer);\n    // console.log('start time after silence threshold: ', thresholdTime);\n\n    const audioBufferMap = new Map<number, AudioBuffer>();\n    audioBufferMap.set(0, audioBuffer);\n\n    this.singleSampleBuffers.clear();\n    this.singleSampleBuffers = audioBufferMap;\n  }\n\n  async loadMulti(samples: SamplePath[]): Promise<void> {\n    const midiBufferMap: Map<number, AudioBuffer> = new Map();\n    const midiStartTimeMap: Map<number, number> = new Map();\n\n    try {\n      console.log('trying to load multi');\n      await Promise.all(\n        samples.map(async ({ midiNote, path }) => {\n          const arrayBuffer = await this.fetchAudioFile(path);\n          const audioBuffer = await this.decodeAudioData(arrayBuffer);\n\n          const thresholdTime = this.detectThresholdCrossing(audioBuffer);\n          // console.log('start time after silence threshold: ', thresholdTime);\n\n          this.multiSampleBuffers.set(midiNote, audioBuffer); // Remove and use midiToBuffers -> loadedInstruments instead ??\n\n          midiBufferMap.set(midiNote, audioBuffer);\n          midiStartTimeMap.set(midiNote, thresholdTime);\n          // for now, only one loaded instrument at a time with id = '0'\n        })\n      );\n\n      this.loadedInstruments.set('0', {\n        midiBufferMap,\n        midiStartTimeMap,\n      });\n\n      console.log('Loaded samples:', this.multiSampleBuffers);\n    } catch (error) {\n      console.error('Failed to load multi-samples:', error);\n      throw error;\n    }\n  }\n\n  createVoiceNode(buffer: AudioBuffer): VoiceNode {\n    const source = this.context.createBufferSource();\n    source.buffer = buffer;\n\n    const gainNode = this.context.createGain();\n    source.connect(gainNode).connect(this.masterGain);\n\n    return { source: source, gain: gainNode };\n  }\n\n  getBufferFromMidi(\n    midiNote: number,\n    mode: 'single-sample' | 'multi-sample' = this.samplerMode\n  ) {\n    console.log('mode: ', mode);\n    switch (mode) {\n      case 'single-sample': // Todo: handle current single sample index if more than one loaded\n        return {\n          buffer: this.singleSampleBuffers.get(0),\n          sampleMidiNote: this.rootMidiNote,\n          // TODO: startTime\n        };\n      case 'multi-sample':\n        if (this.multiSampleBuffers.has(midiNote)) {\n          return {\n            buffer: this.multiSampleBuffers.get(midiNote),\n            sampleMidiNote: midiNote,\n            startTime: this.loadedInstruments\n              .get('0')\n              .midiStartTimeMap.get(midiNote),\n          };\n        } else {\n          const closestMidiNote = this.getClosestMidiNote(midiNote);\n          if (closestMidiNote === null) {\n            throw new Error('No samples available');\n          }\n          return {\n            buffer: this.multiSampleBuffers.get(closestMidiNote),\n            sampleMidiNote: closestMidiNote,\n            startTime: this.loadedInstruments\n              .get('0')\n              .midiStartTimeMap.get(closestMidiNote),\n          };\n        }\n      default:\n        throw new Error('Invalid sampler mode');\n    }\n  }\n\n  getClosestMidiNote(midiNote: number): number | null {\n    const availableMidiNotes = Array.from(this.multiSampleBuffers.keys());\n\n    if (availableMidiNotes.length === 0) {\n      return null;\n    }\n\n    return availableMidiNotes.reduce((closest, current) => {\n      const currentDiff = Math.abs(current - midiNote);\n      const closestDiff = Math.abs(closest - midiNote);\n      return currentDiff < closestDiff ? current : closest;\n    });\n  }\n\n  playNote(\n    midiNote: number,\n    velocity: number = MidiConfig.DEFAULTS.VELOCITY\n  ): void {\n    const { buffer, sampleMidiNote, startTime } =\n      this.getBufferFromMidi(midiNote); // midiOffset => semitone offset of buffer pitch from requested midi note\n    const voice = this.createVoiceNode(buffer);\n\n    // Calculate playback rate based on the sampleMidiNote and requested note to be played\n    let sampleFreq = 440 * Math.pow(2, (sampleMidiNote - 69) / 12);\n    const noteFreq = 440 * Math.pow(2, (midiNote - 69) / 12);\n    voice.source.playbackRate.value = noteFreq / sampleFreq;\n\n    const time = this.context.currentTime; // use the same 'currentTime' for precise scheduling\n    this.triggerAttack(time, voice, velocity);\n\n    voice.source.start(time, startTime ?? 0);\n    this.activeVoiceNodes.set(midiNote, voice);\n  }\n\n  stopNote(midiNote: number): void {\n    const voice = this.activeVoiceNodes.get(midiNote);\n    if (voice) {\n      const time = this.context.currentTime;\n      this.triggerRelease(time, voice);\n      voice.source.stop(time + DEFAULT_RELEASE);\n      this.activeVoiceNodes.delete(midiNote);\n    }\n  }\n\n  triggerAttack(when: number, voiceNode: VoiceNode, velocity: number): void {\n    voiceNode.gain.gain.cancelScheduledValues(this.context.currentTime);\n    voiceNode.gain.gain.setValueAtTime(0, this.context.currentTime);\n    voiceNode.gain.gain.linearRampToValueAtTime(\n      velocity / 127,\n      when + DEFAULT_ATTACK\n    );\n  }\n\n  triggerRelease(when: number, voiceNode: VoiceNode): void {\n    voiceNode.gain.gain.cancelScheduledValues(this.context.currentTime);\n    voiceNode.gain.gain.setValueAtTime(voiceNode.gain.gain.value, when);\n    voiceNode.gain.gain.linearRampToValueAtTime(0, when + DEFAULT_RELEASE);\n  }\n}\n\n// mono version - REMOVE\n// private detectThresholdCrossing(audioBuffer: AudioBuffer): number {\n//   const samples = audioBuffer.getChannelData(0);\n//   const sampleRate = audioBuffer.sampleRate;\n\n//   for (let i = 0; i < samples.length; i++) {\n//     if (Math.abs(samples[i]) > this.silenceThreshold) {\n//       return i / sampleRate; // Convert samples to seconds\n//     }\n//   }\n//   return 0; // No threshold crossing found\n// }\n\n// async loadMulti(dirPath: string) {\n//   // fetch all audio files in directory\n//   // decode audio data\n//   // map each audio buffer to a midi note\n//   // assuming file names are midi note values (e.g. 60.mp3, 62.mp3, etc.)\n//   // replace with manifest file approach if needed - what are the benefits?\n//   // For now, assume all files are valid audio files named after their MIDI note value + extension\n//   // Clear and replace 'multiSampleBuffers' map with new audio buffers\n//   console.log('Not implemented yet');\n// }\n\n// async fetchAndDecodeAudio(path: string): Promise<Map<number, AudioBuffer>> {\n//   // Todo: research difference between resolving the promises here versus returning a promise\n//   let audioBufferMap = new Map<number, AudioBuffer>();\n\n//   if (this.samplerMode === 'multi-sample') {\n//     console.log('multi-sample mode- fetchAndDecodeAudio - IMPLEMENT ME');\n\n//     // const promises = manifest.map(async (midiNote: string) => {\n//     //   const response = await fetch(path + midiNote);\n//     //   const arrayBuffer = await response.arrayBuffer();\n//     //   const audioBuffer = await this.context.decodeAudioData(arrayBuffer);\n//     //   // audio files need to be named after their MIDI note value\n//     //   // Todo: make robust\n\n//     //   // multi-sample mode: maps file-name as midi note to each audio buffer\n//     //   audioBufferMap.set(parseInt(midiNote), audioBuffer);\n//     // });\n//   } else if (this.samplerMode === 'single-sample') {\n//     const arrayBuffer = await this.fetchAudioFile(path);\n\n//     // Check if ArrayBuffer actually has content\n//     console.log('ArrayBuffer length:', arrayBuffer.byteLength);\n\n//     // Look at first few bytes to check header\n//     const firstBytes = new Uint8Array(arrayBuffer.slice(0, 4));\n//     console.log('First bytes:', Array.from(firstBytes));\n\n//     const audioBuffer = await this.decodeAudioData(arrayBuffer);\n//     audioBufferMap.set(0, audioBuffer);\n//   }\n\n//   console.log('audioBufferMap', audioBufferMap);\n\n//   return audioBufferMap;\n// }\n"],"names":["MULTI_DIR","SINGLE_DIR","DEFAULT_MULTI_INSTR_MIDINOTES","a","b","DEFAULT_MULTI_SAMPLE_INSTRUMENT","midiNote","DEFAULT_SINGLE_SAMPLE_INSTRUMENT","DEFAULT_INSTRUMENTS","DEFAULT_CONFIG","MidiConfig","DEFAULT_ATTACK","DEFAULT_RELEASE","WebAudioEngine","mode","voice","audioBuffer","numChannels","sampleRate","samples","_","i","channel","path","response","buffer","arrayBuffer","audioBufferMap","midiBufferMap","midiStartTimeMap","thresholdTime","error","source","gainNode","closestMidiNote","availableMidiNotes","closest","current","currentDiff","closestDiff","velocity","sampleMidiNote","startTime","sampleFreq","noteFreq","time","when","voiceNode"],"mappings":"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"}