{"version":3,"mappings":"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","names":["$RAW","$NODE","$HAS","$SELF","wrap$1","value","p","$PROXY","proxyTraps$1","keys","desc","i","l","prop","isWrappable","obj","proto","unwrap","item","set","result","unwrapped","v","getNodes","target","symbol","nodes","getNode","property","s","createSignal","proxyDescriptor$1","trackSelf","getListener","ownKeys","receiver","$TRACK","tracked","setProperty","state","deleting","prev","len","node","mergeStoreNode","key","updateArray","current","next","updatePath","path","traversed","part","partType","isArray","from","to","by","createStore","store","options","unwrappedStore","wrappedStore","setStore","args","batch","createPlaybackStore","audioEngine","setState","newMode","midiNote","newSet","keymap","KeyboardController","props","handleKeyDown","e","handleKeyUp","createEffect","onCleanup","KeyboardSpline","lazy","__vitePreload","n","Toggle","App","isOffline","setIsOffline","isSplineLoaded","setSplineLoaded","WebAudioEngine","playbackState","playbackActions","onMount","navigator","onLine","initialize","window","addEventListener","removeEventListener","_el$","_tmpl$3","_$insert","_c$","_$memo","_tmpl$4","_$createComponent","Show","when","isInitialized","fallback","_tmpl$5","children","onNoteOn","playNote","onNoteOff","stopNote","Suspense","_tmpl$6","_el$2","_tmpl$","onLoad","_tmpl$7","mode","instrumentMode","onClick","toggleSamplerMode","_el$3","_tmpl$2","firstChild","Array","activeNotes","join","root","document","getElementById","render","registration","err"],"ignoreList":[0],"sources":["../../node_modules/solid-js/store/dist/store.js","../../src/state/stores/playback-store.ts","../../src/ui/input/keymap.ts","../../src/ui/input/KeyboardController.ts","../../src/App.tsx","../../src/index.tsx","../../index.html?html-proxy&index=1.js"],"sourcesContent":["import { $PROXY, $TRACK, getListener, batch, createSignal } from \"solid-js\";\n\nconst $RAW = Symbol(\"store-raw\"),\n  $NODE = Symbol(\"store-node\"),\n  $HAS = Symbol(\"store-has\"),\n  $SELF = Symbol(\"store-self\");\nfunction wrap$1(value) {\n  let p = value[$PROXY];\n  if (!p) {\n    Object.defineProperty(value, $PROXY, {\n      value: (p = new Proxy(value, proxyTraps$1))\n    });\n    if (!Array.isArray(value)) {\n      const keys = Object.keys(value),\n        desc = Object.getOwnPropertyDescriptors(value);\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const prop = keys[i];\n        if (desc[prop].get) {\n          Object.defineProperty(value, prop, {\n            enumerable: desc[prop].enumerable,\n            get: desc[prop].get.bind(p)\n          });\n        }\n      }\n    }\n  }\n  return p;\n}\nfunction isWrappable(obj) {\n  let proto;\n  return (\n    obj != null &&\n    typeof obj === \"object\" &&\n    (obj[$PROXY] ||\n      !(proto = Object.getPrototypeOf(obj)) ||\n      proto === Object.prototype ||\n      Array.isArray(obj))\n  );\n}\nfunction unwrap(item, set = new Set()) {\n  let result, unwrapped, v, prop;\n  if ((result = item != null && item[$RAW])) return result;\n  if (!isWrappable(item) || set.has(item)) return item;\n  if (Array.isArray(item)) {\n    if (Object.isFrozen(item)) item = item.slice(0);\n    else set.add(item);\n    for (let i = 0, l = item.length; i < l; i++) {\n      v = item[i];\n      if ((unwrapped = unwrap(v, set)) !== v) item[i] = unwrapped;\n    }\n  } else {\n    if (Object.isFrozen(item)) item = Object.assign({}, item);\n    else set.add(item);\n    const keys = Object.keys(item),\n      desc = Object.getOwnPropertyDescriptors(item);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      prop = keys[i];\n      if (desc[prop].get) continue;\n      v = item[prop];\n      if ((unwrapped = unwrap(v, set)) !== v) item[prop] = unwrapped;\n    }\n  }\n  return item;\n}\nfunction getNodes(target, symbol) {\n  let nodes = target[symbol];\n  if (!nodes)\n    Object.defineProperty(target, symbol, {\n      value: (nodes = Object.create(null))\n    });\n  return nodes;\n}\nfunction getNode(nodes, property, value) {\n  if (nodes[property]) return nodes[property];\n  const [s, set] = createSignal(value, {\n    equals: false,\n    internal: true\n  });\n  s.$ = set;\n  return (nodes[property] = s);\n}\nfunction proxyDescriptor$1(target, property) {\n  const desc = Reflect.getOwnPropertyDescriptor(target, property);\n  if (!desc || desc.get || !desc.configurable || property === $PROXY || property === $NODE)\n    return desc;\n  delete desc.value;\n  delete desc.writable;\n  desc.get = () => target[$PROXY][property];\n  return desc;\n}\nfunction trackSelf(target) {\n  getListener() && getNode(getNodes(target, $NODE), $SELF)();\n}\nfunction ownKeys(target) {\n  trackSelf(target);\n  return Reflect.ownKeys(target);\n}\nconst proxyTraps$1 = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === $PROXY) return receiver;\n    if (property === $TRACK) {\n      trackSelf(target);\n      return receiver;\n    }\n    const nodes = getNodes(target, $NODE);\n    const tracked = nodes[property];\n    let value = tracked ? tracked() : target[property];\n    if (property === $NODE || property === $HAS || property === \"__proto__\") return value;\n    if (!tracked) {\n      const desc = Object.getOwnPropertyDescriptor(target, property);\n      if (\n        getListener() &&\n        (typeof value !== \"function\" || target.hasOwnProperty(property)) &&\n        !(desc && desc.get)\n      )\n        value = getNode(nodes, property, value)();\n    }\n    return isWrappable(value) ? wrap$1(value) : value;\n  },\n  has(target, property) {\n    if (\n      property === $RAW ||\n      property === $PROXY ||\n      property === $TRACK ||\n      property === $NODE ||\n      property === $HAS ||\n      property === \"__proto__\"\n    )\n      return true;\n    getListener() && getNode(getNodes(target, $HAS), property)();\n    return property in target;\n  },\n  set() {\n    return true;\n  },\n  deleteProperty() {\n    return true;\n  },\n  ownKeys: ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor$1\n};\nfunction setProperty(state, property, value, deleting = false) {\n  if (!deleting && state[property] === value) return;\n  const prev = state[property],\n    len = state.length;\n  if (value === undefined) {\n    delete state[property];\n    if (state[$HAS] && state[$HAS][property] && prev !== undefined) state[$HAS][property].$();\n  } else {\n    state[property] = value;\n    if (state[$HAS] && state[$HAS][property] && prev === undefined) state[$HAS][property].$();\n  }\n  let nodes = getNodes(state, $NODE),\n    node;\n  if ((node = getNode(nodes, property, prev))) node.$(() => value);\n  if (Array.isArray(state) && state.length !== len) {\n    for (let i = state.length; i < len; i++) (node = nodes[i]) && node.$();\n    (node = getNode(nodes, \"length\", len)) && node.$(state.length);\n  }\n  (node = nodes[$SELF]) && node.$();\n}\nfunction mergeStoreNode(state, value) {\n  const keys = Object.keys(value);\n  for (let i = 0; i < keys.length; i += 1) {\n    const key = keys[i];\n    setProperty(state, key, value[key]);\n  }\n}\nfunction updateArray(current, next) {\n  if (typeof next === \"function\") next = next(current);\n  next = unwrap(next);\n  if (Array.isArray(next)) {\n    if (current === next) return;\n    let i = 0,\n      len = next.length;\n    for (; i < len; i++) {\n      const value = next[i];\n      if (current[i] !== value) setProperty(current, i, value);\n    }\n    setProperty(current, \"length\", len);\n  } else mergeStoreNode(current, next);\n}\nfunction updatePath(current, path, traversed = []) {\n  let part,\n    prev = current;\n  if (path.length > 1) {\n    part = path.shift();\n    const partType = typeof part,\n      isArray = Array.isArray(current);\n    if (Array.isArray(part)) {\n      for (let i = 0; i < part.length; i++) {\n        updatePath(current, [part[i]].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"function\") {\n      for (let i = 0; i < current.length; i++) {\n        if (part(current[i], i)) updatePath(current, [i].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"object\") {\n      const { from = 0, to = current.length - 1, by = 1 } = part;\n      for (let i = from; i <= to; i += by) {\n        updatePath(current, [i].concat(path), traversed);\n      }\n      return;\n    } else if (path.length > 1) {\n      updatePath(current[part], path, [part].concat(traversed));\n      return;\n    }\n    prev = current[part];\n    traversed = [part].concat(traversed);\n  }\n  let value = path[0];\n  if (typeof value === \"function\") {\n    value = value(prev, traversed);\n    if (value === prev) return;\n  }\n  if (part === undefined && value == undefined) return;\n  value = unwrap(value);\n  if (part === undefined || (isWrappable(prev) && isWrappable(value) && !Array.isArray(value))) {\n    mergeStoreNode(prev, value);\n  } else setProperty(current, part, value);\n}\nfunction createStore(...[store, options]) {\n  const unwrappedStore = unwrap(store || {});\n  const isArray = Array.isArray(unwrappedStore);\n  const wrappedStore = wrap$1(unwrappedStore);\n  function setStore(...args) {\n    batch(() => {\n      isArray && args.length === 1\n        ? updateArray(unwrappedStore, args[0])\n        : updatePath(unwrappedStore, args);\n    });\n  }\n  return [wrappedStore, setStore];\n}\n\nfunction proxyDescriptor(target, property) {\n  const desc = Reflect.getOwnPropertyDescriptor(target, property);\n  if (\n    !desc ||\n    desc.get ||\n    desc.set ||\n    !desc.configurable ||\n    property === $PROXY ||\n    property === $NODE\n  )\n    return desc;\n  delete desc.value;\n  delete desc.writable;\n  desc.get = () => target[$PROXY][property];\n  desc.set = v => (target[$PROXY][property] = v);\n  return desc;\n}\nconst proxyTraps = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === $PROXY) return receiver;\n    if (property === $TRACK) {\n      trackSelf(target);\n      return receiver;\n    }\n    const nodes = getNodes(target, $NODE);\n    const tracked = nodes[property];\n    let value = tracked ? tracked() : target[property];\n    if (property === $NODE || property === $HAS || property === \"__proto__\") return value;\n    if (!tracked) {\n      const desc = Object.getOwnPropertyDescriptor(target, property);\n      const isFunction = typeof value === \"function\";\n      if (getListener() && (!isFunction || target.hasOwnProperty(property)) && !(desc && desc.get))\n        value = getNode(nodes, property, value)();\n      else if (value != null && isFunction && value === Array.prototype[property]) {\n        return (...args) => batch(() => Array.prototype[property].apply(receiver, args));\n      }\n    }\n    return isWrappable(value) ? wrap(value) : value;\n  },\n  has(target, property) {\n    if (\n      property === $RAW ||\n      property === $PROXY ||\n      property === $TRACK ||\n      property === $NODE ||\n      property === $HAS ||\n      property === \"__proto__\"\n    )\n      return true;\n    getListener() && getNode(getNodes(target, $HAS), property)();\n    return property in target;\n  },\n  set(target, property, value) {\n    batch(() => setProperty(target, property, unwrap(value)));\n    return true;\n  },\n  deleteProperty(target, property) {\n    batch(() => setProperty(target, property, undefined, true));\n    return true;\n  },\n  ownKeys: ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor\n};\nfunction wrap(value) {\n  let p = value[$PROXY];\n  if (!p) {\n    Object.defineProperty(value, $PROXY, {\n      value: (p = new Proxy(value, proxyTraps))\n    });\n    const keys = Object.keys(value),\n      desc = Object.getOwnPropertyDescriptors(value);\n    const proto = Object.getPrototypeOf(value);\n    const isClass =\n      proto !== null &&\n      value !== null &&\n      typeof value === \"object\" &&\n      !Array.isArray(value) &&\n      proto !== Object.prototype;\n    if (isClass) {\n      const descriptors = Object.getOwnPropertyDescriptors(proto);\n      keys.push(...Object.keys(descriptors));\n      Object.assign(desc, descriptors);\n    }\n    for (let i = 0, l = keys.length; i < l; i++) {\n      const prop = keys[i];\n      if (isClass && prop === \"constructor\") continue;\n      if (desc[prop].get) {\n        const get = desc[prop].get.bind(p);\n        Object.defineProperty(value, prop, {\n          get,\n          configurable: true\n        });\n      }\n      if (desc[prop].set) {\n        const og = desc[prop].set,\n          set = v => batch(() => og.call(p, v));\n        Object.defineProperty(value, prop, {\n          set,\n          configurable: true\n        });\n      }\n    }\n  }\n  return p;\n}\nfunction createMutable(state, options) {\n  const unwrappedStore = unwrap(state || {});\n  const wrappedStore = wrap(unwrappedStore);\n  return wrappedStore;\n}\nfunction modifyMutable(state, modifier) {\n  batch(() => modifier(unwrap(state)));\n}\n\nconst $ROOT = Symbol(\"store-root\");\nfunction applyState(target, parent, property, merge, key) {\n  const previous = parent[property];\n  if (target === previous) return;\n  const isArray = Array.isArray(target);\n  if (\n    property !== $ROOT &&\n    (!isWrappable(target) ||\n      !isWrappable(previous) ||\n      isArray !== Array.isArray(previous) ||\n      (key && target[key] !== previous[key]))\n  ) {\n    setProperty(parent, property, target);\n    return;\n  }\n  if (isArray) {\n    if (\n      target.length &&\n      previous.length &&\n      (!merge || (key && target[0] && target[0][key] != null))\n    ) {\n      let i, j, start, end, newEnd, item, newIndicesNext, keyVal;\n      for (\n        start = 0, end = Math.min(previous.length, target.length);\n        start < end &&\n        (previous[start] === target[start] ||\n          (key && previous[start] && target[start] && previous[start][key] === target[start][key]));\n        start++\n      ) {\n        applyState(target[start], previous, start, merge, key);\n      }\n      const temp = new Array(target.length),\n        newIndices = new Map();\n      for (\n        end = previous.length - 1, newEnd = target.length - 1;\n        end >= start &&\n        newEnd >= start &&\n        (previous[end] === target[newEnd] ||\n          (key && previous[start] && target[start] && previous[end][key] === target[newEnd][key]));\n        end--, newEnd--\n      ) {\n        temp[newEnd] = previous[end];\n      }\n      if (start > newEnd || start > end) {\n        for (j = start; j <= newEnd; j++) setProperty(previous, j, target[j]);\n        for (; j < target.length; j++) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        }\n        if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n        return;\n      }\n      newIndicesNext = new Array(newEnd + 1);\n      for (j = newEnd; j >= start; j--) {\n        item = target[j];\n        keyVal = key && item ? item[key] : item;\n        i = newIndices.get(keyVal);\n        newIndicesNext[j] = i === undefined ? -1 : i;\n        newIndices.set(keyVal, j);\n      }\n      for (i = start; i <= end; i++) {\n        item = previous[i];\n        keyVal = key && item ? item[key] : item;\n        j = newIndices.get(keyVal);\n        if (j !== undefined && j !== -1) {\n          temp[j] = previous[i];\n          j = newIndicesNext[j];\n          newIndices.set(keyVal, j);\n        }\n      }\n      for (j = start; j < target.length; j++) {\n        if (j in temp) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        } else setProperty(previous, j, target[j]);\n      }\n    } else {\n      for (let i = 0, len = target.length; i < len; i++) {\n        applyState(target[i], previous, i, merge, key);\n      }\n    }\n    if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n    return;\n  }\n  const targetKeys = Object.keys(target);\n  for (let i = 0, len = targetKeys.length; i < len; i++) {\n    applyState(target[targetKeys[i]], previous, targetKeys[i], merge, key);\n  }\n  const previousKeys = Object.keys(previous);\n  for (let i = 0, len = previousKeys.length; i < len; i++) {\n    if (target[previousKeys[i]] === undefined) setProperty(previous, previousKeys[i], undefined);\n  }\n}\nfunction reconcile(value, options = {}) {\n  const { merge, key = \"id\" } = options,\n    v = unwrap(value);\n  return state => {\n    if (!isWrappable(state) || !isWrappable(v)) return v;\n    const res = applyState(\n      v,\n      {\n        [$ROOT]: state\n      },\n      $ROOT,\n      merge,\n      key\n    );\n    return res === undefined ? state : res;\n  };\n}\nconst producers = new WeakMap();\nconst setterTraps = {\n  get(target, property) {\n    if (property === $RAW) return target;\n    const value = target[property];\n    let proxy;\n    return isWrappable(value)\n      ? producers.get(value) ||\n          (producers.set(value, (proxy = new Proxy(value, setterTraps))), proxy)\n      : value;\n  },\n  set(target, property, value) {\n    setProperty(target, property, unwrap(value));\n    return true;\n  },\n  deleteProperty(target, property) {\n    setProperty(target, property, undefined, true);\n    return true;\n  }\n};\nfunction produce(fn) {\n  return state => {\n    if (isWrappable(state)) {\n      let proxy;\n      if (!(proxy = producers.get(state))) {\n        producers.set(state, (proxy = new Proxy(state, setterTraps)));\n      }\n      fn(proxy);\n    }\n    return state;\n  };\n}\n\nconst DEV = undefined;\n\nexport { $RAW, DEV, createMutable, createStore, modifyMutable, produce, reconcile, unwrap };\n","// src/state/stores/playbackStore.ts\nimport { createStore } from 'solid-js/store';\nimport { WebAudioEngine } from '../../logic/audio/WebAudioEngine';\nimport { MidiNoteUtils } from '../../logic/midi/midiNote';\n\n// Draft - Plan system that can be used in Hljodsmali as well\n\nexport const createPlaybackStore = (audioEngine: WebAudioEngine) => {\n  const [state, setState] = createStore({\n    isInitialized: false,\n    activeNotes: new Set<number>(),\n    instrumentMode: 'single-sample', // 'multi-sample' as 'single-sample' | 'multi-sample',\n  });\n\n  return [\n    state,\n    {\n      initialize: async () => {\n        await audioEngine.initialize();\n        setState('isInitialized', true);\n      },\n      toggleSamplerMode: () => {\n        // check this\n        const newMode =\n          state.instrumentMode === 'multi-sample'\n            ? 'single-sample'\n            : 'multi-sample';\n\n        setState('instrumentMode', newMode);\n        audioEngine.setSamplerMode(newMode as 'single-sample' | 'multi-sample');\n      },\n      playNote: (midiNote: number) => {\n        // todo: add velocity\n        audioEngine.playNote(midiNote);\n        setState('activeNotes', (prev) => new Set(prev).add(midiNote));\n      },\n      stopNote: (midiNote: number) => {\n        audioEngine.stopNote(midiNote);\n        setState('activeNotes', (prev) => {\n          const newSet = new Set(prev);\n          newSet.delete(midiNote);\n          return newSet;\n        });\n      },\n    },\n  ] as const;\n};\n","// Layout for how keyboard keys are mapped midi note values.\n\n/* Using keycodes: gets physical location of key. \n   NOT case-sensitive, ignores character value. */\n\n// Todo: Add alternative layouts for scales and modes\n\ntype KeyMap = {\n  [keyCode: string]: number;\n};\n\nexport const keymap: KeyMap = {\n  KeyZ: 48,\n  KeyS: 49,\n  KeyX: 50,\n  KeyD: 51,\n  KeyC: 52,\n  KeyV: 53,\n  KeyG: 54,\n  KeyB: 55,\n  KeyH: 56,\n  KeyN: 57,\n  KeyJ: 58,\n  KeyM: 59,\n  Comma: 60,\n  KeyL: 61,\n  Period: 62,\n  Semicolon: 63,\n  Slash: 64,\n  KeyQ: 60,\n  Digit2: 61,\n  KeyW: 62,\n  Digit3: 63,\n  KeyE: 64,\n  KeyR: 65,\n  Digit5: 66,\n  KeyT: 67,\n  Digit6: 68,\n  KeyY: 69,\n  Digit7: 70,\n  KeyU: 71,\n  KeyI: 72,\n  Digit9: 73,\n  KeyO: 74,\n  Digit0: 75,\n  KeyP: 76,\n  BracketLeft: 77,\n  Equal: 78,\n  BracketRight: 79,\n};\n","// src/components/input/KeyboardController.tsx\n\nimport { createEffect, onCleanup } from 'solid-js';\nimport { keymap } from './keymap';\n\ninterface Props {\n  onNoteOn: (midiNote: number, velocity?: number) => void;\n  onNoteOff: (midiNote: number) => void;\n}\n\nexport const KeyboardController = (props: Props) => {\n  const handleKeyDown = (e: KeyboardEvent) => {\n    if (e.repeat) return; // Ignore key repeat events\n    const midiNote = keymap[e.code];\n\n    if (midiNote) {\n      props.onNoteOn(midiNote, 100); // Todo: add velocity\n      // console.log('Key pressed:', e.code, 'MIDI note:', midiNote);\n    }\n  };\n\n  const handleKeyUp = (e: KeyboardEvent) => {\n    const midiNote = keymap[e.code];\n    if (midiNote) {\n      props.onNoteOff(midiNote);\n      // console.log('Key released:', e.code, 'MIDI note:', midiNote);\n    }\n  };\n\n  createEffect(() => {\n    window.addEventListener('keydown', handleKeyDown);\n    window.addEventListener('keyup', handleKeyUp);\n\n    onCleanup(() => {\n      window.removeEventListener('keydown', handleKeyDown);\n      window.removeEventListener('keyup', handleKeyUp);\n    });\n  });\n\n  return null;\n};\n","// src/App.tsx\nimport {\n  Component,\n  createSignal,\n  lazy,\n  Suspense,\n  onMount,\n  Show,\n} from 'solid-js';\nimport { WebAudioEngine } from './logic/audio/WebAudioEngine';\nimport { createPlaybackStore } from './state/stores/playback-store';\nimport { KeyboardController } from './ui/input/KeyboardController';\n\n// Lazy load non-critical components\nconst KeyboardSpline = lazy(() => import('./ui/ui-components/KeyboardSpline'));\nconst Toggle = lazy(() => import('./ui/ui-components/Buttons/Toggle'));\n\nconst App: Component = () => {\n  const [isOffline, setIsOffline] = createSignal(false);\n  const [isSplineLoaded, setSplineLoaded] = createSignal(false);\n\n  const audioEngine = new WebAudioEngine();\n  const [playbackState, playbackActions] = createPlaybackStore(audioEngine);\n\n  onMount(() => {\n    // Check initial state\n    setIsOffline(!navigator.onLine);\n\n    // Initialize\n    playbackActions.initialize();\n\n    // Add listeners\n    window.addEventListener('online', () => setIsOffline(false));\n    window.addEventListener('offline', () => setIsOffline(true));\n\n    // Clean up on unmount\n    return () => {\n      window.removeEventListener('online', () => setIsOffline(false));\n      window.removeEventListener('offline', () => setIsOffline(true));\n    };\n  });\n\n  return (\n    <div class='min-h-screen bg-gray-900 text-white p-4 flex flex-col justify-center items-center'>\n      {isOffline() && (\n        <div class='fixed top-0 w-full bg-yellow-600 text-white text-center py-2'>\n          You are currently offline. Some features may be limited.\n        </div>\n      )}\n\n      <Show\n        when={playbackState.isInitialized}\n        fallback={\n          <div class='animate-pulse'>\n            <span class='inline-block px-4 py-2 bg-gray-800 rounded'>\n              Initializing...\n            </span>\n          </div>\n        }\n      >\n        <KeyboardController\n          onNoteOn={playbackActions.playNote}\n          onNoteOff={playbackActions.stopNote}\n        />\n\n        <Suspense\n          fallback={\n            <div class='w-full h-64 bg-gray-800 animate-pulse rounded-lg'></div>\n          }\n        >\n          <div id='keyboardWrapper'>\n            <KeyboardSpline\n              onLoad={() => setSplineLoaded(true)}\n              // Optional props:\n              // width='100vw'\n              // height='100vh'\n              // mixBlendMode='hard-light'\n              // sceneUrl='https://your-custom-scene-url.splinecode' // Alternative scene: will use default if not provided\n            />\n          </div>\n        </Suspense>\n\n        <Suspense\n          fallback={\n            <div class='mt-4 w-24 h-8 bg-gray-800 animate-pulse rounded'></div>\n          }\n        >\n          <Toggle\n            mode={playbackState.instrumentMode}\n            onClick={playbackActions.toggleSamplerMode}\n            class='mt-4'\n          />\n        </Suspense>\n\n        <Show when={isSplineLoaded()}>\n          <div class='mt-4 font-mono text-sm opacity-75'>\n            Active Notes: {Array.from(playbackState.activeNotes).join(', ')}\n          </div>\n        </Show>\n      </Show>\n    </div>\n  );\n};\n\nexport default App;\n","/* @refresh reload */\nimport './index.css';\nimport { render } from 'solid-js/web';\n\nimport App from './App';\n\nconst root = document.getElementById('root');\n\nif (import.meta.env.DEV && !(root instanceof HTMLElement)) {\n  throw new Error(\n    'Root element not found. Did you forget to add it to your index.html? Or maybe the id attribute got misspelled?',\n  );\n}\n\nrender(() => <App />, root!);\n","\n      if ('serviceWorker' in navigator) {\n        window.addEventListener('load', () => {\n          // Don't register service worker in development\n          if (import.meta.env.DEV) {\n            console.log('Skipping service worker registration in development');\n            return;\n          }\n\n          navigator.serviceWorker\n            .register('/service-worker.js')\n            .then((registration) => {\n              console.log('ServiceWorker registration successful');\n            })\n            .catch((err) => {\n              console.log('ServiceWorker registration failed: ', err);\n            });\n        });\n      }\n    "],"file":"assets/index-BWfcGgt3.js"}